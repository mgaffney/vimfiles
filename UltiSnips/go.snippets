# Snippets for Go

snippet package "Package declaration" b
// Copyright `date +%Y` Good Technologies. All rights reserved.

// Package $1 provides ${2:...}
package ${1:main}
${0:${VISUAL}}
endsnippet

snippet ipa "Get External IP address" b

$0// externalIP returns the external ip address of the machine the process is
// running on.
func externalIP() (string, error) {
	ifaces, err := net.Interfaces()
	if err != nil {
		return "", err
	}
	for _, iface := range ifaces {
		if iface.Flags&net.FlagUp == 0 {
			continue // interface down
		}
		if iface.Flags&net.FlagLoopback != 0 {
			continue // loopback interface
		}
		addrs, err := iface.Addrs()
		if err != nil {
			return "", err
		}
		for _, addr := range addrs {
			var ip net.IP
			switch v := addr.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}
			if ip == nil || ip.IsLoopback() {
				continue
			}
			ip = ip.To4()
			if ip == nil {
				continue // not an ipv4 address
			}
			return ip.String(), nil
		}
	}
	return "", errors.New("are you connected to the network?")
}
endsnippet

# shorthand variable declaration
snippet : "v := value"
${1} := ${0}
endsnippet

# anonymous function
snippet anon "fn := func() { ... }"
${1:fn} := func() {
	${2:${VISUAL}}
}
${0}
endsnippet

# append
snippet ap "append(slice, value)"
append(${1:slice}, ${0:value})
endsnippet

# break
snippet br "break"
break
endsnippet

# channel
snippet ch "chan Type"
chan ${0:int}
endsnippet

# case
snippet case "case ...:"
case ${1:value}:
	${0}
endsnippet

# constant
snippet con "const XXX Type = ..."
const ${1:NAME} ${2:Type} = ${0:0}
endsnippet

# constants
snippet cons "const ( ... )"
const (
	${1:NAME} ${2:Type} = ${3:value}
	${0}
)
endsnippet

# constants with iota
snippet iota "const ( ... = iota )"
const (
	${1:NAME} ${2:Type} = iota
	${0}
)
endsnippet

# continue
snippet cn "continue"
continue
endsnippet

# default case
snippet default "default: ..."
default:
	${0}

endsnippet

# defer
snippet df "defer someFunction()"
defer ${1:func}(${2})
${0}
endsnippet

snippet def "defer func() { ... }"
defer func() {
	${0}
}()
endsnippet

# defer recover
snippet defr
defer func() {
	if err := recover(); err != nil {
		${0}
	}
}()
endsnippet

# import
snippet import "import ( ... )"
import (
	"${1:package}"
)
endsnippet

# full interface snippet
snippet interface "interface I { ... }"
type ${1:Interface} interface {
	${2:/* TODO: add methods */}
}
endsnippet

# if condition
snippet if "if ... { ... }"
if ${1:condition} {
	${0}
}
endsnippet

# else snippet
snippet else
else {
	${0}
}
endsnippet

# error snippet
snippet errn "Error return " !b
if err != nil {
	return err
}
${0}
endsnippet

snippet errn, "Error return with two return values" !b
if err != nil {
	return ${1:nil}, err
}
${0}
endsnippet

snippet json "\`json:key\`"
\`json:"${1:keyName}"\`
endsnippet

# fallthrough
snippet ft "fallthrough"
fallthrough
endsnippet

# for loop
snippet for "for ... { ... }"
for ${1} {
	${0}
}
endsnippet

# for integer loop
snippet fori "for 0..N-1 { ... }"
for ${1:i} := 0; $1 < ${2:N}; $1++ {
	${0}
}
endsnippet

# for range loop
snippet forr "for k, v := range items { ... }"
for ${2:k}, ${3:v} := range ${1} {
	${0}
}
endsnippet

# function
snippet func "func Function(...) [error] { ... }"
func ${1:name}(${2:params})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {
	${0:${VISUAL}}
}
endsnippet

# Fmt Printf debug
snippet ff "fmt.Printf(...)"
fmt.Printf("${1:${VISUAL}} = %+v\n", $1)
endsnippet

# Fmt Println debug
snippet fn "fmt.Println(...)"
fmt.Println("${1}")
endsnippet

# log printf
snippet lf "log.Printf(...)"
log.Printf("${1} = %+v\n", $1)
endsnippet

# log println
snippet ln "log.Println(...)"
log.Println("${1}")
endsnippet

# make
snippet make "make(Type, size)"
make(${1:[]string}, ${2:0})${0}
endsnippet

# map
snippet map "map[Type]Type"
map[${1:string}]${0:int}
endsnippet

# main()
snippet main "func main() { ... }"
func main() {
	${0}
}
endsnippet

# method
snippet meth "func (self Type) Method(...) [error] { ... }"
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
	${0:${VISUAL}}
}
endsnippet

# ok
snippet ok "if !ok { ... }"
if !ok {
	${0}
}
endsnippet

# panic
snippet pn "panic()"
panic("${0:msg}")
endsnippet

# return
snippet rt "return"
return ${0}
endsnippet

# select
snippet select "select { case a := <-chan: ... }"
select {
case ${1:v1} := <-${2:chan1}
	${0}
}
endsnippet

# struct
snippet st "type T struct { ... }"
type ${1:Type} struct {
${0}
}
endsnippet

# switch
snippet switch "switch x { ... }"
switch ${1:var} {
case ${2:value1}:
	${0}
}
endsnippet

# sprintf
snippet sp "fmt.Sprintf(...)"
fmt.Sprintf("%${1:s}", ${2:var})
endsnippet

# goroutine named function
snippet go "go someFunc(...)"
go ${1:funcName}(${0})
endsnippet

# goroutine anonymous function
snippet gof "go func() { ... }()"
go func() {
	${1:${VISUAL}}
}()
${0}
endsnippet

# test function
snippet test "func TestXYZ(t *testing.T) { ... }"
func Test${1:Function}(t *testing.T) {
	${0}
}
endsnippet

# variable declaration
snippet var "var x Type [= ...]"
var ${1:x} ${2:Type}${3: = ${0:value\}}
endsnippet

# variables declaration
snippet vars "var ( ... )"
var (
${1:x} ${2:Type}${3: = ${0:value\}}
)
endsnippet

global !p

import re

# Automatically wrap return types with parentheses

def return_values(s):
	# remove everything wrapped in parentheses
	s = re.sub("\(.*?\)|\([^)]*$", "", s)
	return len(s.split(","))

def opening_par(snip, pos):
	if return_values(t[pos]) > 1 and not t[pos].startswith("("):
		snip.rv = "("
	else:
		snip.rv = ""

def closing_par(snip, pos):
	if return_values(t[pos]) > 1:
		snip.rv = ")"
	else:
		snip.rv = ""

endglobal


# vim:ft=snippets:
